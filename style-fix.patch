 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/index.html b/index.html
index 27039d178d6591b6daad82c8b6f21d21100ffe24..98a6e50972773f77dfba43a63fe949ce001928bf 100644
--- a/index.html
+++ b/index.html
@@ -253,121 +253,134 @@
       box-shadow: 0 0 0 rgba(90, 245, 197, 0.5);
       animation: pulse 2s infinite;
     }
 
     .slot-window {
       --spin-dim: 0.25;
       --tile-fade: 0.15;
       --spin-blur: 0;
       position: relative;
       border: 2px solid #c7923e;
       background: radial-gradient(circle at 50% 20%, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.22)),
         linear-gradient(180deg, #0d1018, #151b26 40%, #0d1119);
       border-radius: 18px;
       height: clamp(360px, 45vw, 520px);
       width: min(1300px, 96vw);
       display: flex;
       align-items: center;
       justify-content: center;
       overflow: hidden;
       box-shadow: inset 0 0 0 4px rgba(255, 255, 255, 0.08), 0 24px 48px rgba(0, 0, 0, 0.55);
       isolation: isolate;
       margin: 0 auto;
       transition: transform 260ms ease;
       will-change: transform, filter;
       transform: translateZ(0);
-      display: flex;
-      align-items: center;
-      justify-content: center;
+      perspective: 1200px;
     }
 
     .slot-window:not(.spinning):hover {
       box-shadow: inset 0 0 0 4px rgba(255, 255, 255, 0.1), 0 32px 64px rgba(0, 0, 0, 0.6);
       border-color: #f8c268;
     }
 
     .slot-glow {
       position: absolute;
       width: 60%;
       height: 140%;
       background: radial-gradient(circle at 50% 40%, rgba(255, 202, 126, 0.32), rgba(255, 255, 255, 0));
       filter: blur(38px);
       transform: translateX(-30%);
       opacity: 0.9;
       z-index: 0;
       animation: drift 9s ease-in-out infinite;
     }
 
     .slot-glow-right {
       left: auto;
       right: -20%;
       transform: translateX(30%);
       background: radial-gradient(circle at 50% 60%, rgba(120, 182, 255, 0.35), rgba(255, 255, 255, 0));
       opacity: 0.6;
       animation-delay: 1.2s;
     }
 
     .slot-reel {
       display: flex;
       align-items: center;
+      justify-content: center;
       gap: 14px;
-      transform: translateX(0);
-      transition: transform 160ms ease;
       filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.35));
       will-change: transform, filter, opacity;
       transform: translateZ(0);
+      transform-style: preserve-3d;
+      backface-visibility: hidden;
     }
 
     .slot-tile {
       width: clamp(260px, 32vw, 360px);
       height: clamp(260px, 32vw, 360px);
       display: grid;
       place-items: center;
       background: radial-gradient(circle at 50% 18%, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.3));
       border-radius: 14px;
       border: 1px solid rgba(255, 255, 255, 0.1);
       box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), 0 0 0 1px rgba(0, 0, 0, 0.3);
       overflow: hidden;
       position: relative;
+      isolation: isolate;
+    }
+
+    .slot-tile::before {
+      content: '';
+      position: absolute;
+      inset: 8%;
+      background: url('assets/coin.svg') center/contain no-repeat;
+      filter: drop-shadow(0 16px 24px rgba(0, 0, 0, 0.35));
+      z-index: 1;
+      opacity: 0.95;
+    }
+
+    .slot-tile::after {
+      content: '';
+      position: absolute;
+      inset: 0;
+      background: radial-gradient(circle at 50% 18%, rgba(255, 255, 255, 0.18), rgba(0, 0, 0, 0.4));
+      mix-blend-mode: soft-light;
+      z-index: 2;
+      pointer-events: none;
     }
 
-    .slot-tile img, .slot-tile .slot-none {
-      width: 80%;
-      height: 80%;
+    .slot-tile img {
+      width: 62%;
+      height: 62%;
       object-fit: contain;
       transition: opacity 180ms ease, transform 180ms ease, filter 240ms ease;
       position: relative;
       z-index: 3;
-      filter: brightness(calc(1 - var(--tile-fade)));
-    }
-
-    .slot-none {
-      color: #ff9ea8;
-      font-weight: 800;
-      font-size: 1.35rem;
-      text-transform: uppercase;
-      letter-spacing: 0.05em;
+      filter: grayscale(0.25) brightness(calc(0.85 - var(--tile-fade))) drop-shadow(0 6px 10px rgba(0, 0, 0, 0.45));
+      mix-blend-mode: multiply;
     }
 
     .slot-label {
       position: absolute;
       bottom: 10px;
       left: 50%;
       transform: translateX(-50%);
       width: 90%;
       text-align: center;
       display: flex;
       align-items: center;
       justify-content: center;
       font-weight: 800;
       color: #ffe59a;
       text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
       letter-spacing: 0.08em;
       z-index: 5;
     }
 
     .slot-readout {
       margin-top: 0.75rem;
       padding: 0.85rem 1rem;
       border-radius: 14px;
       background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(0, 0, 0, 0.28));
       border: 1px solid rgba(255, 255, 255, 0.08);
@@ -631,57 +644,55 @@
       }
     }
 
     .slot-window::before,
     .slot-window::after {
       content: '';
       position: absolute;
       inset: 0;
       pointer-events: none;
       transition: opacity 240ms ease, background 240ms ease;
       will-change: opacity, background;
     }
 
     .slot-window::before {
       background: radial-gradient(circle at 50% 10%, rgba(255, 255, 255, 0.12), transparent 45%);
       z-index: 1;
     }
 
     .slot-window::after {
       background: linear-gradient(90deg, rgba(0, 0, 0, var(--spin-dim)), transparent 28%, transparent 72%, rgba(0, 0, 0, var(--spin-dim)));
       z-index: 4;
       opacity: 0.45;
     }
 
     .slot-window.spinning .slot-reel {
-      filter: brightness(0.9) drop-shadow(0 14px 28px rgba(0, 0, 0, 0.45))
-        blur(calc(var(--spin-blur) * 18px));
+      filter: brightness(0.95) drop-shadow(0 14px 28px rgba(0, 0, 0, 0.45));
       transition: transform 160ms ease, filter 220ms ease;
     }
 
-    .slot-window.spinning .slot-tile img,
-    .slot-window.spinning .slot-tile .slot-none {
+    .slot-window.spinning .slot-tile img {
       filter: brightness(calc(0.4 - (var(--tile-fade) * 0.2)));
     }
 
     .slot-window.spinning::after {
       opacity: 0.8;
     }
 
     .slot-window.spinning::before {
       animation: shimmer 1.6s ease-in-out infinite;
     }
 
     .slot-window.reveal .slot-tile {
       animation: pop-in 360ms cubic-bezier(0.25, 1.35, 0.5, 1);
     }
 
     @keyframes pop-in {
       0% {
         transform: scale(0.9);
         opacity: 0.4;
       }
       45% {
         transform: scale(1.05);
         opacity: 1;
       }
       100% {
@@ -736,51 +747,51 @@
         transform: translateX(-30%) scale(1);
       }
     }
 
     @keyframes shimmer {
       0% {
         opacity: 0.3;
         transform: translateX(-40%);
       }
       50% {
         opacity: 0.75;
         transform: translateX(40%);
       }
       100% {
         opacity: 0.3;
         transform: translateX(-40%);
       }
     }
   </style>
 </head>
 <body>
   <div class="page">
   <header class="hidden-copy">
     <h1>Candy Vending Machine</h1>
     <p>Press button <strong>A</strong> on the micro:bit to spin a one-column candy vending machine. The browser weights the spin toward the chosen preference
-      (75% preferred candy, 15% the other option, 10% no candy), shows the pulled item, and sends the result back to the micro:bit
+      (75% preferred candy, 25% the other option), shows the pulled item, and sends the result back to the micro:bit
       so the Hummingbird can react.</p>
   </header>
 
   <section>
     <div class="row">
       <button id="connect">Connect micro:bit (Web Serial)</button>
       <button id="disconnect" disabled>Disconnect</button>
       <div id="bypass" class="pill">Bypass: off</div>
     </div>
     <p class="hint hidden-copy">Use a Chromium-based browser with <code>navigator.serial</code>. Only the host computer with the micro:bit plugged in
       should connect; guests can still watch the log via the join code.</p>
   </section>
 
   <section id="share-section" class="codes-hidden">
     <h2 class="hidden-copy">Share this session</h2>
     <p class="hint hidden-copy">Host on the machine with the micro:bit attached. Share the join code so others can watch the log in real time.</p>
     <div class="row join-wrap code-contents">
       <label class="select-wrap">Role
         <select id="role">
           <option value="host">Host (micro:bit plugged in)</option>
           <option value="guest">Guest (view log)</option>
         </select>
       </label>
       <div id="host-code" class="pill">Join code: <code id="join-code">—</code></div>
       <div id="guest-join" class="row" style="display: none; align-items: center;">
@@ -823,104 +834,101 @@
   </section>
 
   <section>
     <h2>Log</h2>
     <textarea id="log" readonly>Click "Connect" to request access to the micro:bit serial port...\n</textarea>
   </section>
   </div>
 
   <div id="pref-overlay" class="pref-overlay" aria-hidden="true">
     <div class="pref-panel" role="dialog" aria-modal="true" aria-labelledby="pref-title">
       <div class="pref-head">
         <div>
           <h2 id="pref-title">Pick your candy before this roll</h2>
           <div id="pref-note" class="pref-note">You must pick a preference before every spin.</div>
         </div>
         <div class="slot-actions" aria-hidden="true" style="margin: 0;">
           <button id="pref-confirm" disabled>Lock in &amp; spin</button>
         </div>
       </div>
       <div class="options">
         <label class="option-card" tabindex="0">
           <input type="radio" id="pref-kitkat" name="preference" value="kitkat" />
           <img src="assets/kitkat.png" alt="KitKat" />
           <div>
             <div class="option-title">Prefer KitKat (75% odds)</div>
-            <div class="hint">Otherwise 15% Jolly Rancher, 10% no candy.</div>
+            <div class="hint">Otherwise 25% Jolly Rancher.</div>
           </div>
         </label>
         <label class="option-card" tabindex="0">
           <input type="radio" id="pref-jolly" name="preference" value="jolly" />
           <img src="assets/jolly-rancher.png" alt="Jolly Rancher" />
           <div>
             <div class="option-title">Prefer Jolly Rancher (75% odds)</div>
-            <div class="hint">Otherwise 15% KitKat, 10% no candy.</div>
+            <div class="hint">Otherwise 25% KitKat.</div>
           </div>
         </label>
       </div>
       <div class="pref-actions">
         <button id="pref-cancel" type="button">Cancel</button>
         <button id="pref-confirm-bottom" type="button" disabled>Lock in &amp; spin</button>
       </div>
     </div>
   </div>
 
   <div class="preferences hidden-copy" aria-hidden="true">
     <p class="hint hidden-copy">Preferences now appear as a front-layer prompt whenever you roll so you can set the odds each time.</p>
   </div>
 
   <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
   <script>
     const connectBtn = document.querySelector('#connect');
     const disconnectBtn = document.querySelector('#disconnect');
     const logArea = document.querySelector('#log');
     const roleSelect = document.querySelector('#role');
     const hostCodeWrap = document.querySelector('#host-code');
     const joinCodeLabel = document.querySelector('#join-code');
     const guestJoinWrap = document.querySelector('#guest-join');
     const joinInput = document.querySelector('#join-input');
     const joinBtn = document.querySelector('#join-btn');
     const joinStatus = document.querySelector('#join-status');
     const slotWindow = document.querySelector('.slot-window');
     const slotReel = document.querySelector('#slot-reel');
     const slotLabel = document.querySelector('#slot-label');
     const statusChip = document.querySelector('#status-chip');
     const statusChipText = document.querySelector('#status-chip-text');
     const statusText = document.querySelector('#status-text');
     const bypassBadge = document.querySelector('#bypass');
     const preferenceRadios = document.querySelectorAll('input[name="preference"]');
     const prefOverlay = document.querySelector('#pref-overlay');
     const prefConfirm = document.querySelector('#pref-confirm');
     const prefConfirmBottom = document.querySelector('#pref-confirm-bottom');
     const prefCancel = document.querySelector('#pref-cancel');
     const prefNote = document.querySelector('#pref-note');
     const rollBtn = document.querySelector('#roll-btn');
     const shareSection = document.querySelector('#share-section');
-    const reelOrder = ['kitkat', 'jolly', 'none'];
-    const tileStridePx = 300;
-    let cachedStride = null;
-    let resizeRaf = null;
+    const outcomes = ['kitkat', 'jolly'];
 
     let port;
     let reader;
     let writer;
     let textEncoder;
     let textDecoder;
     let readableStreamClosed;
     let writableStreamClosed;
     let readLoopActive = false;
     let role = 'host';
     let peer;
     let hostConnection;
     const remoteConnections = new Map();
     let spinInProgress = false;
     let bypassMicrobit = false;
     let activePreference = null;
     let pendingSpinSource = null;
     let prefAutoSpin = true;
     let preferencePrimed = false;
     let codesVisible = false;
     let lastDialPreference = null;
     let crankVerify = false;
 
     // ✅ PATCH: dial only works when preference prompt was opened by sensor 1, and stops once spin starts
     let dialWindowActive = false;
@@ -1135,273 +1143,181 @@
     function applyDialPreference(rawValue) {
       if (!dialWindowActive) return;
       if (!prefOverlay.classList.contains('open')) return;
 
       const upper = String(rawValue || '').trim().toUpperCase();
       if (!upper) return;
 
       const normalized =
         upper.includes('JOLLY') ? 'jolly' :
         upper.includes('KITKAT') ? 'kitkat' :
         null;
 
       if (!normalized) return;
       if (normalized === lastDialPreference) return;
 
       lastDialPreference = normalized;
       setPreference(normalized);
 
       prefNote.textContent = `Rotary dial: ${normalized === 'kitkat' ? 'KitKat' : 'Jolly Rancher'} (live).`;
       prefConfirm.disabled = false;
       prefConfirmBottom.disabled = false;
     }
 
     function pickOutcome() {
       const pref = currentPreference();
-      if (!pref) return 'none';
+      if (!pref) return 'kitkat';
       const roll = Math.random();
       if (roll < 0.75) return pref;
-      if (roll < 0.9) return pref === 'kitkat' ? 'jolly' : 'kitkat';
-      return 'none';
+      return pref === 'kitkat' ? 'jolly' : 'kitkat';
     }
 
     function outcomeLabel(outcome) {
       if (outcome === 'kitkat') return 'Pulled: KitKat';
       if (outcome === 'jolly') return 'Pulled: Jolly Rancher';
-      return 'Pulled: no candy';
+      return 'Pulled: KitKat';
     }
 
     // ✅ PATCH: dial window active ONLY when opened by sensor 1
     function openPreferencePrompt(source, options = {}) {
       dialWindowActive = String(source).toLowerCase().includes('sensor 1');
 
       const { autoSpin = true, primeOnly = false } = options;
       pendingSpinSource = source;
       prefAutoSpin = autoSpin;
       if (primeOnly) preferencePrimed = true;
 
       clearPreference({ resetDial: false });
 
       if (lastDialPreference) {
         setPreference(lastDialPreference);
         prefNote.textContent = `Rotary dial picked ${lastDialPreference === 'kitkat' ? 'KitKat' : 'Jolly Rancher'}.`;
       } else {
         prefNote.textContent = `Triggered by ${source}. Pick a preference for this roll.`;
       }
 
       prefConfirm.disabled = !currentPreference();
       prefConfirmBottom.disabled = !currentPreference();
       prefOverlay.classList.add('open');
       prefOverlay.setAttribute('aria-hidden', 'false');
       log(`Preference needed for ${source} — choose KitKat or Jolly to continue.`);
     }
 
     function closePreferencePrompt() {
       prefOverlay.classList.remove('open');
       prefOverlay.setAttribute('aria-hidden', 'true');
     }
 
     function tileForOutcome(outcome) {
       const tile = document.createElement('div');
       tile.className = 'slot-tile';
       tile.dataset.outcome = outcome;
-      if (outcome === 'none') {
-        const none = document.createElement('img');
-        none.src = 'assets/no-candy.jpg';
-        none.alt = 'No candy';
-        tile.appendChild(none);
-      } else {
-        const img = document.createElement('img');
-        img.src = outcome === 'kitkat' ? 'assets/kitkat.png' : 'assets/jolly-rancher.png';
-        img.alt = outcome === 'kitkat' ? 'KitKat' : 'Jolly Rancher';
-        tile.appendChild(img);
-      }
+      const img = document.createElement('img');
+      img.src = outcome === 'kitkat' ? 'assets/kitkat.png' : 'assets/jolly-rancher.png';
+      img.alt = outcome === 'kitkat' ? 'KitKat' : 'Jolly Rancher';
+      tile.appendChild(img);
       return tile;
     }
 
-    function measureStride() {
-      if (cachedStride !== null) return cachedStride;
-      const sampleTile = slotReel.querySelector('.slot-tile');
-      cachedStride = sampleTile ? sampleTile.getBoundingClientRect().width + 14 : tileStridePx;
-      return cachedStride;
-    }
-
-    function renderStaticOutcome(outcome) {
+    function renderStaticOutcome(outcome, options = {}) {
+      const { updateLabel = true } = options;
       slotReel.innerHTML = '';
       slotReel.appendChild(tileForOutcome(outcome));
-      cachedStride = null;
-      const stride = measureStride();
-      const offset = centeredPosition(0, stride);
-      slotReel.style.transform = `translateX(${offset}px)`;
-      slotLabel.textContent = outcomeLabel(outcome);
-    }
-
-    function buildReel(sequence) {
-      slotReel.innerHTML = '';
-      sequence.forEach((outcome) => slotReel.appendChild(tileForOutcome(outcome)));
-      cachedStride = null;
-      const stride = measureStride();
-      const offset = centeredPosition(0, stride);
-      slotReel.style.transform = `translateX(${offset}px)`;
-    }
-
-    function centeredPosition(tick, stride) {
-      const offset = (slotWindow.clientWidth - stride) / 2;
-      return offset - tick * stride;
-    }
-
-    function refreshStaticOffset() {
-      if (spinInProgress) return;
-      const stride = measureStride();
-      const offset = centeredPosition(0, stride);
-      slotReel.style.transform = `translateX(${offset}px)`;
-    }
-
-    function lerp(a, b, t) {
-      return a + (b - a) * t;
-    }
-
-    function easeOutCubic(t) {
-      return 1 - Math.pow(1 - t, 3);
+      slotReel.style.transform = 'rotateY(0deg)';
+      if (updateLabel) slotLabel.textContent = outcomeLabel(outcome);
     }
 
     function wait(ms) {
       if (!('requestAnimationFrame' in window)) return new Promise((resolve) => setTimeout(resolve, ms));
       return new Promise((resolve) => {
         const start = performance.now();
         function step(now) {
           if (now - start >= ms) { resolve(); return; }
           requestAnimationFrame(step);
         }
         requestAnimationFrame(step);
       });
     }
 
-    function spinSpacing(elapsed, accel, cruise, decel) {
-      const start = 55;
-      const mid = 150;
-      const settle = 680;
-      if (elapsed < accel) {
-        const t = elapsed / accel;
-        return lerp(start, mid, easeOutCubic(t));
-      }
-      if (elapsed < accel + cruise) {
-        const t = (elapsed - accel) / cruise;
-        return lerp(mid, mid * 1.1, t);
-      }
-      const t = Math.min(1, (elapsed - accel - cruise) / decel);
-      return lerp(mid * 1.05, settle, easeOutCubic(t));
-    }
-
     async function animateSpin(finalOutcome) {
       spinInProgress = true;
       slotWindow.classList.add('spinning');
       slotWindow.classList.remove('reveal');
-      slotLabel.textContent = 'Spinning...';
-      const reelStyle = slotReel.style;
+      slotLabel.textContent = 'Flipping...';
       const windowStyle = slotWindow.style;
-      windowStyle.setProperty('--spin-blur', 0.9);
-      windowStyle.setProperty('--spin-dim', 0.4);
-      windowStyle.setProperty('--tile-fade', 0.35);
-
-      const sequence = [];
-      const baseLength = 32;
-      for (let i = 0; i < baseLength; i += 1) sequence.push(reelOrder[i % reelOrder.length]);
-      sequence.push(finalOutcome, finalOutcome);
-
-      buildReel(sequence);
-      cachedStride = null;
-      const stride = measureStride();
-
-      let tick = 0;
-      const accel = 620;
-      const cruise = 1200;
-      const decel = 1800;
-      const total = accel + cruise + decel;
-      let elapsed = 0;
-
-      while (elapsed < total) {
-        const spacing = spinSpacing(elapsed, accel, cruise, decel);
-        const phase = Math.min(1, elapsed / total);
-        const dim = Math.min(0.92, 0.28 + Math.pow(phase, 1.2) * 0.75);
-        const fade = Math.min(0.9, 0.22 + phase * 0.7);
-        const blur = Math.max(0, 0.95 - phase * 1.05);
-        windowStyle.setProperty('--spin-dim', dim.toFixed(2));
-        windowStyle.setProperty('--tile-fade', fade.toFixed(2));
-        windowStyle.setProperty('--spin-blur', blur.toFixed(2));
-
-        await wait(spacing);
-        tick = (tick + 1) % sequence.length;
-        const offset = centeredPosition(tick, stride);
-        reelStyle.transition = `transform ${Math.max(140, Math.min(320, spacing * 0.7))}ms cubic-bezier(0.2, 0.8, 0.3, 1)`;
-        reelStyle.transform = `translateX(${offset}px)`;
-        elapsed += spacing;
+      windowStyle.setProperty('--spin-blur', 0);
+      windowStyle.setProperty('--spin-dim', 0.35);
+      windowStyle.setProperty('--tile-fade', 0.2);
+
+      const randomOutcome = () => outcomes[Math.floor(Math.random() * outcomes.length)];
+      renderStaticOutcome(randomOutcome(), { updateLabel: false });
+
+      const flips = 7;
+      for (let i = 0; i < flips; i += 1) {
+        const next = i === flips - 1 ? finalOutcome : randomOutcome();
+        const duration = 260 + i * 80;
+        const flip = slotReel.animate(
+          [
+            { transform: 'rotateY(0deg) scale(1)', filter: 'brightness(1)' },
+            { transform: 'rotateY(90deg) scale(0.92)', filter: 'brightness(0.7)' },
+            { transform: 'rotateY(180deg) scale(1)', filter: 'brightness(1)' },
+          ],
+          { duration, easing: 'cubic-bezier(0.45, 0.1, 0.15, 1.1)' }
+        );
+
+        await wait(duration / 2);
+        renderStaticOutcome(next, { updateLabel: false });
+        await flip.finished;
+        slotReel.style.transform = 'rotateY(0deg)';
       }
 
-      const finalIndex = sequence.lastIndexOf(finalOutcome);
-      const previewOffset = centeredPosition(Math.max(0, finalIndex - 1), stride);
-      const finalOffset = centeredPosition(finalIndex, stride);
-      reelStyle.transition = 'transform 520ms cubic-bezier(0.16, 0.85, 0.3, 1)';
-      reelStyle.transform = `translateX(${previewOffset}px)`;
-      windowStyle.setProperty('--spin-dim', 0.82);
-      windowStyle.setProperty('--spin-blur', 0.2);
-      await wait(420);
-      reelStyle.transition = 'transform 640ms cubic-bezier(0.15, 0.95, 0.24, 1.05)';
-      reelStyle.transform = `translateX(${finalOffset}px)`;
-      windowStyle.setProperty('--spin-dim', 0.9);
-      await wait(620);
-
       slotWindow.classList.remove('spinning');
       renderStaticOutcome(finalOutcome);
       slotWindow.classList.add('reveal');
-      windowStyle.setProperty('--spin-dim', 0.25);
-      windowStyle.setProperty('--tile-fade', 0.12);
+      windowStyle.setProperty('--spin-dim', 0.22);
+      windowStyle.setProperty('--tile-fade', 0.1);
       windowStyle.setProperty('--spin-blur', 0);
       await wait(420);
       slotWindow.classList.remove('reveal');
       spinInProgress = false;
     }
 
     async function runSpin(triggerSource) {
       if (!currentPreference()) {
         log('Pick a preference first.');
         return;
       }
 
       // ✅ PATCH: stop dial immediately when the slot machine starts rolling
       dialWindowActive = false;
 
       const outcome = pickOutcome();
       log(`Vending spin (${triggerSource}): pref=${currentPreference()}, outcome=${outcome}`);
       setStatus('spin', `Spinning via ${triggerSource}...`);
       await animateSpin(outcome);
 
-      const message = outcome === 'kitkat'
-        ? 'PAYOUT KITKAT'
-        : outcome === 'jolly'
-          ? 'PAYOUT JOLLY'
-          : 'PAYOUT NONE';
+      const message = outcome === 'kitkat' ? 'PAYOUT KITKAT' : 'PAYOUT JOLLY';
 
       await sendRaw(message);
       setStatus('ok', 'Spin finished—result sent to the micro:bit.');
       preferencePrimed = false;
       clearPreference();
       if (String(triggerSource).toLowerCase().includes('motion 2')) resetCrankFlow();
     }
 
     async function triggerSpin(triggerSource) {
       if (role === 'guest') {
         log('Guests cannot spin; the host needs to run the vending machine.');
         return;
       }
       const sourceText = typeof triggerSource === 'string' ? triggerSource.toLowerCase() : '';
       const isMotion2 = sourceText.includes('motion 2');
       if (isMotion2 && !crankVerify) {
         log('Spin ignored until motion sensor 1 arms the crank.');
         return;
       }
       if (!crankVerify && sourceText.includes('keyboard')) {
         crankVerify = true;
         log('Keyboard spin armed the crank flow.');
       }
       if (!preferencePrimed && !isMotion2) {
         log('Waiting for motion sensor 2 to open the preference prompt before spinning.');
@@ -1653,46 +1569,37 @@
     });
 
     document.addEventListener('keydown', (event) => {
       if (event.key && event.key.toLowerCase() === 'a') {
         const active = document.activeElement;
         if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.tagName === 'SELECT')) return;
         triggerSpin('keyboard A');
         return;
       }
       if (event.key && event.key.toLowerCase() === 'b') {
         const active = document.activeElement;
         if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.tagName === 'SELECT')) return;
         if (!bypassMicrobit) {
           setBypass(true);
           log('Bypass enabled via keyboard B: spins can run without a connected micro:bit.');
         }
         return;
       }
       if (event.key && event.key.toLowerCase() === 's') {
         const active = document.activeElement;
         if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.tagName === 'SELECT')) return;
         toggleCodesVisibility();
       }
     });
 
-    window.addEventListener('resize', () => {
-      cachedStride = null;
-      if (resizeRaf) cancelAnimationFrame(resizeRaf);
-      resizeRaf = requestAnimationFrame(() => {
-        refreshStaticOffset();
-        resizeRaf = null;
-      });
-    });
-
     applyCodeVisibility();
     setBypass(false);
     renderStaticOutcome('kitkat');
     slotWindow.style.setProperty('--spin-dim', 0.25);
     slotWindow.style.setProperty('--tile-fade', 0.15);
     slotLabel.textContent = 'Waiting for button A...';
     setStatus('idle', 'Press button A on the micro:bit or tap A on the keyboard to roll.');
     updateRoleUI();
     ensurePeer();
   </script>
 </body>
 </html>
 
EOF
)
